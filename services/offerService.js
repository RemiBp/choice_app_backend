const Offer = require('../models/Offer');

/**
 * Creates a new offer in the database.
 * @param {string} producerId - ID of the producer sending the offer.
 * @param {string} targetUserId - ID of the user receiving the offer.
 * @param {string} title - Title of the offer.
 * @param {string} body - Body/description of the offer.
 * @param {number} [discountPercentage] - Optional discount percentage.
 * @param {number} validityDurationMinutes - How long the offer is valid for (in minutes).
 * @param {string} [originalSearchQuery] - Optional triggering search query.
 * @param {string} [triggeringSearchId] - Optional ID of the UserActivity search event.
 * @returns {Promise<object>} The created offer document.
 * @throws {Error} If creation fails.
 */
async function createOffer(producerId, targetUserId, title, body, discountPercentage, validityDurationMinutes, originalSearchQuery, triggeringSearchId) {
  try {
    if (!producerId || !targetUserId || !title || !body || !validityDurationMinutes) {
      throw new Error('Missing required fields for creating offer.');
    }

    const expiresAt = new Date(Date.now() + validityDurationMinutes * 60 * 1000);

    const newOfferData = {
      producerId,
      targetUserId,
      title,
      body,
      discountPercentage,
      expiresAt,
      originalSearchQuery,
      triggeringSearchId,
      status: 'pending', // Initial status
      // offerCode is generated by the model default
    };

    const offer = new Offer(newOfferData);
    await offer.save();

    console.log(`✨ Offer created: ${offer._id} (Code: ${offer.offerCode}) for user ${targetUserId} from producer ${producerId}`);
    return offer.toObject(); // Return plain JS object

  } catch (error) {
    console.error('❌ Error creating offer in service:', error);
    // Rethrow or handle specific errors (like duplicate offerCode, although unlikely with nanoid)
    throw error;
  }
}

/**
 * Allows a user to accept a pending offer.
 * @param {string} offerId - The ID of the offer to accept.
 * @param {string} userId - The ID of the user attempting to accept.
 * @returns {Promise<object>} The updated offer document.
 * @throws {Error} If the offer cannot be accepted (not found, wrong user, expired, wrong status).
 */
async function acceptOffer(offerId, userId) {
  try {
    if (!offerId || !userId) {
      throw new Error('Offer ID and User ID are required to accept.');
    }

    const offer = await Offer.findById(offerId);

    // Check 1: Offer exists
    if (!offer) {
      throw new Error('Offer not found.');
    }

    // Check 2: Offer belongs to the user
    if (offer.targetUserId.toString() !== userId.toString()) {
      console.warn(`User ${userId} attempted to accept offer ${offerId} belonging to ${offer.targetUserId}`);
      throw new Error('Offer does not belong to this user.');
    }

    // Check 3: Offer status is acceptable (e.g., pending or sent)
    // Allow accepting only once
    if (!['pending', 'sent'].includes(offer.status)) {
       console.warn(`Offer ${offerId} has status ${offer.status} and cannot be accepted.`);
      throw new Error('Offer cannot be accepted.'); // e.g., already accepted, validated, expired
    }

    // Check 4: Offer has not expired
    if (offer.expiresAt < new Date()) {
       console.warn(`Offer ${offerId} expired at ${offer.expiresAt}.`);
      // Optionally update status to expired here
      // await Offer.findByIdAndUpdate(offerId, { status: 'expired' });
      throw new Error('Offer cannot be accepted.'); // Treat expired same as wrong status for user
    }

    // All checks passed, update status to 'accepted'
    offer.status = 'accepted';
    await offer.save();

    console.log(`✅ Offer ${offerId} accepted by user ${userId}`);
    return offer.toObject(); // Return the updated offer

  } catch (error) {
    console.error(`❌ Error accepting offer ${offerId} for user ${userId}:`, error.message);
    // Rethrow specific validation errors for controller handling
    if (error.message === 'Offer not found.' || error.message === 'Offer does not belong to this user.' || error.message === 'Offer cannot be accepted.') {
        throw error;
    }
    // Throw generic error for unexpected issues
    throw new Error('Failed to process offer acceptance.');
  }
}

/**
 * Retrieves offers targeted at a specific user, optionally filtered by status.
 * Populates producer information.
 * @param {string} userId - The ID of the user whose offers are being retrieved.
 * @param {string} [statusFilter] - Optional status to filter by (e.g., 'pending', 'accepted').
 * @param {number} [limit=20] - Max number of offers to return.
 * @param {number} [skip=0] - Number of offers to skip for pagination.
 * @returns {Promise<Array<object>>} A list of offer documents with producer info populated.
 * @throws {Error} If retrieval fails.
 */
async function getReceivedOffersForUser(userId, statusFilter, limit = 20, skip = 0) {
  try {
    if (!userId) {
      throw new Error('User ID is required to get received offers.');
    }

    const query = { targetUserId: userId };
    if (statusFilter) {
      // Basic validation for allowed statuses if needed
      const allowedStatuses = ['pending', 'sent', 'accepted', 'validated', 'expired', 'rejected', 'cancelled'];
      if (allowedStatuses.includes(statusFilter)) {
           query.status = statusFilter;
      } else {
          console.warn(`getReceivedOffersForUser: Invalid status filter ignored: ${statusFilter}`);
      }
    }

    // Find offers, sort by newest first, populate producer details
    const offers = await Offer.find(query)
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(limit)
      .populate({
        path: 'producerId',
        select: 'name profilePicture username' // Select fields needed for display
      })
      .lean(); // Use lean for performance if not modifying docs

    console.log(`Retrieved ${offers.length} offers for user ${userId}` + (statusFilter ? ` with status ${statusFilter}` : ''));
    return offers;

  } catch (error) {
    console.error(`❌ Error getting received offers for user ${userId}:`, error);
    throw new Error('Failed to retrieve received offers.');
  }
}

/**
 * Validates an offer based on its unique code, typically scanned via QR.
 * Checks if the offer belongs to the validating producer, is accepted, and not expired.
 * Updates the status to 'validated' if all checks pass.
 * @param {string} offerCode - The unique code of the offer (e.g., 'CHO-ABC123').
 * @param {string} validatingProducerId - The ID of the producer attempting the validation.
 * @returns {Promise<object>} The validated offer document.
 * @throws {Error} If the offer cannot be validated.
 */
async function validateOfferByCode(offerCode, validatingProducerId) {
  try {
    if (!offerCode || !validatingProducerId) {
      throw new Error('Offer code and validating producer ID are required.');
    }

    // Find the offer by its unique code
    const offer = await Offer.findOne({ offerCode: offerCode });

    // Check 1: Offer exists
    if (!offer) {
      throw new Error(`Offer not found for code: ${offerCode}`);
    }

    // Check 2: Offer belongs to the validating producer
    if (offer.producerId.toString() !== validatingProducerId.toString()) {
      console.warn(`Producer ${validatingProducerId} attempted to validate offer ${offer._id} (code: ${offerCode}) belonging to producer ${offer.producerId}`);
      // Return 'not found' to avoid revealing offer existence to wrong producer
      throw new Error(`Offer not found for code: ${offerCode}`);
    }

    // Check 3: Offer status must be 'accepted'
    if (offer.status !== 'accepted') {
      console.warn(`Offer ${offer._id} (code: ${offerCode}) has status ${offer.status} and cannot be validated.`);
      throw new Error(`Offer cannot be validated (Status: ${offer.status}).`);
    }

    // Check 4: Offer has not expired (redundant if status is already 'accepted', but good practice)
    if (offer.expiresAt < new Date()) {
      console.warn(`Offer ${offer._id} (code: ${offerCode}) expired at ${offer.expiresAt}.`);
      // Optionally update status to expired here if it wasn't already
      // await Offer.findByIdAndUpdate(offer._id, { status: 'expired' });
      throw new Error('Offer cannot be validated (Expired).');
    }

    // All checks passed, update status to 'validated'
    offer.status = 'validated';
    offer.validatedAt = new Date();
    await offer.save();

    console.log(`✅ Offer ${offer._id} (Code: ${offerCode}) validated by producer ${validatingProducerId}`);
    // TODO: Consider emitting an event or notification to the user that the offer was used?
    
    return offer.toObject(); // Return the validated offer

  } catch (error) {
    console.error(`❌ Error validating offer code ${offerCode} by producer ${validatingProducerId}:`, error.message);
    // Rethrow specific validation errors for controller handling
    if (error.message.includes('not found') || error.message.includes('cannot be validated')) {
        throw error;
    }
    // Throw generic error for unexpected issues
    throw new Error('Failed to process offer validation.');
  }
}

/**
 * Allows a user to reject a pending offer.
 * @param {string} offerId - The ID of the offer to reject.
 * @param {string} userId - The ID of the user attempting to reject.
 * @returns {Promise<object>} The updated offer document.
 * @throws {Error} If the offer cannot be rejected (not found, wrong user, expired, wrong status).
 */
async function rejectOffer(offerId, userId) {
  try {
    if (!offerId || !userId) {
      throw new Error('Offer ID and User ID are required to reject.');
    }

    const offer = await Offer.findById(offerId);

    // Check 1: Offer exists
    if (!offer) {
      throw new Error('Offer not found.');
    }

    // Check 2: Offer belongs to the user
    if (offer.targetUserId.toString() !== userId.toString()) {
      console.warn(`User ${userId} attempted to reject offer ${offerId} belonging to ${offer.targetUserId}`);
      throw new Error('Offer does not belong to this user.');
    }

    // Check 3: Offer status is rejectable (e.g., pending or sent)
    // Allow rejecting only if not already rejected, validated, or expired
    if (!['pending', 'sent'].includes(offer.status)) {
       console.warn(`Offer ${offerId} has status ${offer.status} and cannot be rejected.`);
      throw new Error('Offer cannot be rejected.'); // e.g., already rejected, validated, expired
    }

    // All checks passed, update status to 'rejected'
    offer.status = 'rejected';
    await offer.save();

    console.log(`✅ Offer ${offerId} rejected by user ${userId}`);
    return offer.toObject(); // Return the updated offer

  } catch (error) {
    console.error(`❌ Error rejecting offer ${offerId} for user ${userId}:`, error.message);
    // Rethrow specific validation errors for controller handling
    if (error.message === 'Offer not found.' || error.message === 'Offer does not belong to this user.' || error.message === 'Offer cannot be rejected.') {
        throw error;
    }
    // Throw generic error for unexpected issues
    throw new Error('Failed to process offer rejection.');
  }
}

module.exports = {
  createOffer,
  acceptOffer,
  getReceivedOffersForUser,
  validateOfferByCode,
  rejectOffer,
  // Add other offer-related service functions here later (validate, etc.)
}; 