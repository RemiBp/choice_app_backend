/**
 * Routes API pour les requ√™tes IA avec acc√®s MongoDB en temps r√©el
 * Ces routes permettent aux utilisateurs et producteurs d'interroger l'IA
 * qui a un acc√®s direct et en temps r√©el aux bases de donn√©es MongoDB.
 */

const express = require('express');
const router = express.Router();
const { processUserQuery, processProducerQuery, getFriendsChoices, getPlacesWithMostChoices } = require('../services/aiDataService');
const mongoose = require('mongoose');
const { choiceAppDb, restaurationDb, loisirDb, beautyWellnessDb } = require('../index');
const aiController = require('../controllers/aiController');
const { requireAuth } = require('../middleware/authMiddleware');

// Middleware to check if the authenticated user has access to the requested producer AI features
// This needs to be defined BEFORE it's used in the routes below
const checkProducerAccess = (req, res, next) => {
    const { producerType, producerId } = req.params;
    const requestingUserId = req.user?.id; // Assuming authenticateToken attached user
    const requestingProducerId = req.producer?._id?.toString(); // Assuming authenticateToken attached producer

    // Allow access if the authenticated entity is the producer itself
    if (requestingProducerId && requestingProducerId === producerId) {
         return next();
    }

    // Allow access if the authenticated entity is a user linked to the producer (e.g., owner/manager)
    // TODO: Implement logic to check user-producer relationship (e.g., from a Producer model)
    // Example placeholder check:
    // const producer = await ProducerModel.findById(producerId).populate('managers');
    // if (producer && producer.managers.some(manager => manager._id.toString() === requestingUserId)) {
    //    return next();
    // }

    // Simplified check for now: Let's assume if req.user exists and matches producerId (e.g., producer logged in as user)
    // THIS IS LIKELY INSECURE AND NEEDS PROPER RELATIONSHIP CHECKING
    if (requestingUserId && requestingUserId === producerId) {
         return next();
    }

    console.warn(`Unauthorized AI access attempt for producer ${producerId} (${producerType}) by user ${requestingUserId} or producer ${requestingProducerId}`);
    res.status(403).json({ message: 'Forbidden: Access denied to this producer\'s AI features.' });
};

/**
 * @route POST /api/ai/query
 * @description Endpoint de test simple sans authentification
 * @example
 * // Requ√™te: "Donne-moi les restaurants de la base qui font du saumon"
 * {
 *   "query": "Donne-moi les restaurants de la base qui font du saumon"
 * }
 */
router.post('/query', async (req, res) => {
  try {
    const { query, options } = req.body;
    
    if (!query) {
      return res.status(400).json({
        success: false,
        message: 'Le param√®tre query est requis'
      });
    }
    
    console.log(`üß™ TEST: Traitement de la requ√™te: "${query}" (sans authentification)`);
    
    // Traiter la requ√™te avec acc√®s complet aux donn√©es MongoDB
    // Note: nous passons query en premier, puis null comme userId (param√®tre correct)
    const result = await processUserQuery(query, null, options || {});
    
    console.log(`üìä TEST: R√©sultats - ${result.resultCount || 0} r√©sultats trouv√©s (type: ${result.intent || 'inconnu'})`);
    if (result.profiles && result.profiles.length > 0) {
      console.log(`üîç TEST: ${result.profiles.length} profils extraits`);
    }
    
    // Format de r√©ponse direct pour faciliter les tests
    return res.json({
      success: true,
      query: result.query,
      intent: result.intent,
      entities: result.entities,
      resultCount: result.resultCount || 0,
      executionTimeMs: result.executionTimeMs,
      response: result.response,
      profiles: result.profiles || []
    });
  } catch (error) {
    console.error('‚ùå TEST: Erreur lors du traitement de la requ√™te:', error);
    return res.status(500).json({
      success: false,
      query: req.body.query,
      error: "Erreur lors du traitement de la requ√™te",
      response: "D√©sol√©, une erreur s'est produite lors du traitement de votre requ√™te. Veuillez r√©essayer.",
      profiles: []
    });
  }
});

/**
 * @route POST /api/ai/user/query
 * @description Traite une requ√™te utilisateur en langage naturel
 * @example
 * // Requ√™te: "Propose-moi un spectacle fun ce soir"
 * {
 *   "userId": "user123",
 *   "query": "Propose-moi un spectacle fun ce soir"
 * }
 */
router.post('/user/query', async (req, res) => {
  try {
    const { userId, query } = req.body;
    
    if (!userId || !query) {
      return res.status(400).json({
        success: false,
        message: 'Les param√®tres userId et query sont requis'
      });
    }
    
    console.log(`üîç Traitement de la requ√™te utilisateur: "${query}" (userId: ${userId})`);
    
    // Traiter la requ√™te avec acc√®s complet aux donn√©es MongoDB
    const result = await processUserQuery(query, userId);
    
    console.log(`üìä R√©sultats - ${result.resultCount || 0} r√©sultats trouv√©s (type: ${result.intent || 'inconnu'})`);
    if (result.profiles && result.profiles.length > 0) {
      console.log(`üîç ${result.profiles.length} profils extraits`);
    }
    
    // Format de r√©ponse direct
    return res.json({
      success: true,
      query: result.query,
      intent: result.intent,
      entities: result.entities,
      resultCount: result.resultCount || 0,
      executionTimeMs: result.executionTimeMs,
      response: result.response,
      profiles: result.profiles || []
    });
  } catch (error) {
    console.error('‚ùå Erreur lors du traitement de la requ√™te utilisateur:', error);
    return res.status(500).json({
      success: false,
      query: req.body.query,
      error: "Erreur lors du traitement de la requ√™te",
      response: "D√©sol√©, une erreur s'est produite lors du traitement de votre requ√™te. Veuillez r√©essayer.",
      profiles: []
    });
  }
});

/**
 * @route POST /api/ai/producer/query
 * @description Traite une requ√™te producteur en langage naturel (analyses, comparaisons)
 * @example
 * // Requ√™te: "Aide-moi √† am√©liorer ma carte en comparaison des autres restaurants du quartier"
 * {
 *   "producerId": "prod456",
 *   "query": "Aide-moi √† am√©liorer ma carte en comparaison des autres restaurants du quartier"
 * }
 */
router.post('/producer/query', async (req, res) => {
  try {
    const { producerId, query } = req.body;
    
    if (!producerId || !query) {
      return res.status(400).json({
        success: false,
        message: 'Les param√®tres producerId et query sont requis'
      });
    }
    
    console.log(`üîç Traitement de la requ√™te producteur: "${query}" (producerId: ${producerId})`);
    
    // Traiter la requ√™te avec acc√®s complet aux donn√©es MongoDB
    const result = await processProducerQuery(query, producerId);
    
    console.log(`üìä R√©sultats - ${result.resultCount || 0} r√©sultats trouv√©s (type: ${result.intent || 'inconnu'})`);
    
    // Format de r√©ponse direct
    return res.json({
      success: true,
      query: result.query,
      intent: result.intent,
      entities: result.entities,
      resultCount: result.resultCount || 0,
      executionTimeMs: result.executionTimeMs,
      response: result.response,
      profiles: result.profiles || [],
      analysisResults: result.analysisResults || null
    });
  } catch (error) {
    console.error('‚ùå Erreur lors du traitement de la requ√™te producteur:', error);
    return res.status(500).json({
      success: false,
      query: req.body.query,
      error: "Erreur lors du traitement de la requ√™te",
      response: "D√©sol√©, une erreur s'est produite lors du traitement de votre requ√™te. Veuillez r√©essayer.",
      profiles: []
    });
  }
});

/**
 * @route GET /api/ai/insights/user/:userId
 * @description Obtient des insights personnalis√©s pour un utilisateur
 */
router.get('/insights/user/:userId', async (req, res) => {
  try {
    const { userId } = req.params;
    
    if (!userId) {
      return res.status(400).json({
        success: false,
        message: 'Le param√®tre userId est requis'
      });
    }
    
    console.log(`üîç G√©n√©ration d'insights pour l'utilisateur: ${userId}`);
    
    // Ex√©cute automatiquement une requ√™te personnalis√©e bas√©e sur les go√ªts de l'utilisateur
    const query = "Recommande-moi des √©v√©nements ou restaurants qui pourraient m'int√©resser bas√©s sur mes pr√©f√©rences";
    const result = await processUserQuery(query, userId);
    
    console.log(`üìä Insights g√©n√©r√©s avec ${result.profiles?.length || 0} profils extraits`);
    
    // Format de r√©ponse direct
    return res.json({
      success: true,
      query: query,
      response: result.response,
      profiles: result.profiles || [],
      executionTimeMs: result.executionTimeMs || 0
    });
  } catch (error) {
    console.error('‚ùå Erreur lors de la g√©n√©ration des insights utilisateur:', error);
    return res.status(500).json({
      success: false,
      error: "Erreur lors de la g√©n√©ration des insights",
      response: "D√©sol√©, une erreur s'est produite lors de la g√©n√©ration des insights. Veuillez r√©essayer.",
      profiles: []
    });
  }
});

/**
 * @route GET /api/ai/insights/producer/:producerId
 * @description Obtient des insights commerciaux pour un producteur
 */
router.get('/insights/producer/:producerId', async (req, res) => {
  try {
    const { producerId } = req.params;
    
    if (!producerId) {
      return res.status(400).json({
        success: false,
        message: 'Le param√®tre producerId est requis'
      });
    }
    
    console.log(`üîç G√©n√©ration d'insights pour le producteur: ${producerId}`);
    
    // Ex√©cute automatiquement une requ√™te d'analyse personnalis√©e
    const query = "Analyse ma performance commerciale par rapport aux concurrents de mon quartier et donne-moi les trois principales recommandations pour am√©liorer ma visibilit√©";
    const result = await processProducerQuery(query, producerId);
    
    console.log(`üìä Insights commerciaux g√©n√©r√©s avec ${result.profiles?.length || 0} profils extraits`);
    
    // Format de r√©ponse direct
    return res.json({
      success: true,
      query: query,
      response: result.response,
      profiles: result.profiles || [],
      analysisResults: result.analysisResults || null,
      executionTimeMs: result.executionTimeMs || 0
    });
  } catch (error) {
    console.error('‚ùå Erreur lors de la g√©n√©ration des insights producteur:', error);
    return res.status(500).json({
      success: false,
      error: "Erreur lors de la g√©n√©ration des insights",
      response: "D√©sol√©, une erreur s'est produite lors de la g√©n√©ration des insights. Veuillez r√©essayer.",
      profiles: []
    });
  }
});

/**
 * @route GET /api/ai/health
 * @description V√©rifie l'√©tat de sant√© du service IA
 */
router.get('/health', async (req, res) => {
  try {
    // V√©rification simple de l'√©tat du service
    res.json({
      success: true,
      status: 'operational',
      message: 'Le service IA est op√©rationnel'
    });
  } catch (error) {
    console.error('‚ùå Erreur lors de la v√©rification de l\'√©tat du service IA:', error);
    return res.status(500).json({
      success: false,
      status: 'error',
      message: 'Le service IA rencontre des probl√®mes',
      error: error.message
    });
  }
});

/**
 * @route POST /api/ai/generate-vibe-map
 * @desc G√©n√©rer une carte sensorielle bas√©e sur un "vibe"
 * @access Public
 */
router.post('/generate-vibe-map', async (req, res) => {
  try {
    const { userId, vibe, location } = req.body;
    
    if (!vibe) {
      return res.status(400).json({ 
        success: false,
        message: 'Vibe (ambiance) requis pour la g√©n√©ration de la carte' 
      });
    }
    
    // Faire une requ√™te interne √† notre service de carte sensorielle
    const serviceResponse = await fetch(`${process.env.BASE_URL || 'http://localhost:3000'}/api/map/vibe`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        vibe,
        location,
        limit: 15
      }),
    });
    
    if (!serviceResponse.ok) {
      throw new Error(`Service error: ${serviceResponse.status}`);
    }
    
    const vibeData = await serviceResponse.json();
    
    // Enregistrer cette requ√™te pour l'historique utilisateur si userId fourni
    if (userId) {
      try {
        await UserQuery.create({
          userId,
          type: 'vibe_map',
          query: vibe,
          context: {
            location: location || 'global',
            timestamp: new Date()
          },
          result: {
            matchCount: vibeData.profiles.length,
            topMatch: vibeData.profiles.length > 0 ? vibeData.profiles[0].name : null
          }
        });
      } catch (historyError) {
        console.error('Erreur lors de l\'enregistrement de l\'historique:', historyError);
        // Ne pas √©chouer la requ√™te principale si l'historique √©choue
      }
    }
    
    res.status(200).json(vibeData);
  } catch (error) {
    console.error('‚ùå Erreur lors de la g√©n√©ration de la carte sensorielle:', error);
    res.status(500).json({ 
      success: false,
      message: 'Erreur lors de la g√©n√©ration de la carte sensorielle', 
      error: error.message 
    });
  }
});

/**
 * @route GET /api/ai/detect-producer-type/:producerId
 * @desc Detect the type of a producer (restaurant, leisureProducer, wellnessProducer, etc.)
 * @access Public
 */
router.get('/detect-producer-type/:producerId', async (req, res) => {
  const { producerId } = req.params;
  
  if (!producerId) {
    return res.status(400).json({ success: false, message: 'ProducerId is required' });
  }
  
  try {
    // Try to find the producer in different collections
    const collections = [
      { name: 'restaurant', db: restaurationDb, collection: 'Lieux_Paris' },
      { name: 'leisureProducer', db: loisirDb, collection: 'leisure_producers' },
      { name: 'wellnessProducer', db: beautyWellnessDb, collection: 'wellness_producers' },
      { name: 'beautyPlace', db: beautyWellnessDb, collection: 'beauty_places' }
    ];
    
    let producerType = 'unknown';
    
    for (const { name, db, collection } of collections) {
      try {
        const model = db.model(collection, new mongoose.Schema({}, { strict: false }), collection);
        const producer = await model.findOne({ _id: producerId });
        
        if (producer) {
          producerType = name;
          break;
        }
      } catch (err) {
        console.error(`Error checking collection ${collection}: ${err.message}`);
        // Continue to the next collection
      }
    }
    
    // If we didn't find the producer in any collection, try a more general approach
    if (producerType === 'unknown') {
      try {
        // Try the producers collection in the main choice_app database
        const Producer = choiceAppDb.model('Producer');
        const producer = await Producer.findById(producerId);
        
        if (producer) {
          // Try to determine the type based on properties in the document
          if (producer.type) {
            producerType = producer.type;
          } else if (producer.producer_type) {
            producerType = producer.producer_type;
          } else {
            producerType = 'restaurant'; // Default if we can't determine
          }
        }
      } catch (err) {
        console.error(`Error checking main producer collection: ${err.message}`);
        // Fall back to default
        producerType = 'restaurant';
      }
    }
    
    res.status(200).json({
      success: true,
      producerType,
      message: producerType !== 'unknown' ? 
        `Producer identified as ${producerType}` : 
        'Could not determine producer type, defaulting to restaurant'
    });
  } catch (error) {
    console.error('Error detecting producer type:', error);
    res.status(500).json({
      success: false,
      message: 'Error detecting producer type',
      error: error.message
    });
  }
});

/**
 * @route POST /api/ai/leisure-query
 * @description Traite une requ√™te pour producteur de loisirs
 * @access Public
 */
router.post('/leisure-query', async (req, res) => {
  try {
    const { producerId, query, producerType } = req.body;
    
    if (!producerId || !query) {
      return res.status(400).json({
        success: false,
        message: 'ProducerId et query sont requis'
      });
    }
    
    console.log(`üéÆ Traitement de la requ√™te loisirs: "${query}" (producerId: ${producerId})`);
    
    // Appel au service de traitement avec le type sp√©cifique
    const result = await processProducerQuery(query, producerId, 'leisureProducer');
    
    // S'assurer que les profils sont bien normalis√©s
    if (result.profiles && Array.isArray(result.profiles)) {
      result.profiles = result.profiles.map(profile => {
        if (profile.type === 'leisureProducer') {
          return normalizeLeisureProducerData(profile);
        }
        return profile;
      });
    }
    
    console.log(`üìä R√©sultats - ${result.profiles?.length || 0} profils normalis√©s trouv√©s`);
    
    return res.json({
      success: true,
      response: result.response,
      profiles: result.profiles || [],
      analysisResults: result.analysisResults || null
    });
  } catch (error) {
    console.error('‚ùå Erreur lors du traitement de la requ√™te loisir:', error);
    return res.status(500).json({
      success: false,
      error: "Erreur lors du traitement de la requ√™te",
      response: "D√©sol√©, une erreur s'est produite lors du traitement de votre requ√™te. Veuillez r√©essayer.",
      profiles: []
    });
  }
});

/**
 * @route POST /api/ai/wellness-query
 * @description Traite une requ√™te pour producteur de bien-√™tre
 * @access Public
 */
router.post('/wellness-query', async (req, res) => {
  try {
    const { producerId, query, producerType } = req.body;
    
    if (!producerId || !query) {
      return res.status(400).json({
        success: false,
        message: 'ProducerId et query sont requis'
      });
    }
    
    console.log(`üíÜ Traitement de la requ√™te bien-√™tre: "${query}" (producerId: ${producerId})`);
    
    // Appel au service de traitement avec le type sp√©cifique
    const result = await processProducerQuery(query, producerId, 'wellnessProducer');
    
    console.log(`üìä R√©sultats - ${result.profiles?.length || 0} profils trouv√©s`);
    
    return res.json({
      success: true,
      response: result.response,
      profiles: result.profiles || [],
      analysisResults: result.analysisResults || null
    });
  } catch (error) {
    console.error('‚ùå Erreur lors du traitement de la requ√™te bien-√™tre:', error);
    return res.status(500).json({
      success: false,
      error: "Erreur lors du traitement de la requ√™te",
      response: "D√©sol√©, une erreur s'est produite lors du traitement de votre requ√™te. Veuillez r√©essayer.",
      profiles: []
    });
  }
});

/**
 * @route POST /api/ai/beauty-query
 * @description Traite une requ√™te pour √©tablissement de beaut√©
 * @access Public
 */
router.post('/beauty-query', async (req, res) => {
  try {
    const { producerId, query, producerType } = req.body;
    
    if (!producerId || !query) {
      return res.status(400).json({
        success: false,
        message: 'ProducerId et query sont requis'
      });
    }
    
    console.log(`üíÖ Traitement de la requ√™te beaut√©: "${query}" (producerId: ${producerId})`);
    
    // Appel au service de traitement avec le type sp√©cifique
    const result = await processProducerQuery(query, producerId, 'beautyPlace');
    
    console.log(`üìä R√©sultats - ${result.profiles?.length || 0} profils trouv√©s`);
    
    return res.json({
      success: true,
      response: result.response,
      profiles: result.profiles || [],
      analysisResults: result.analysisResults || null
    });
  } catch (error) {
    console.error('‚ùå Erreur lors du traitement de la requ√™te beaut√©:', error);
    return res.status(500).json({
      success: false,
      error: "Erreur lors du traitement de la requ√™te",
      response: "D√©sol√©, une erreur s'est produite lors du traitement de votre requ√™te. Veuillez r√©essayer.",
      profiles: []
    });
  }
});

/**
 * @route POST /api/ai/user/producer-query
 * @description Traite une requ√™te pour restaurant (compatibilit√© avec le type par d√©faut)
 * @access Public
 */
router.post('/user/producer-query', async (req, res) => {
  try {
    const { producerId, query } = req.body;
    
    if (!producerId || !query) {
      return res.status(400).json({
        success: false,
        message: 'ProducerId et query sont requis'
      });
    }
    
    console.log(`üçΩÔ∏è Traitement de la requ√™te restaurant: "${query}" (producerId: ${producerId})`);
    
    // Appel au service de traitement avec le type par d√©faut
    const result = await processProducerQuery(query, producerId, 'restaurant');
    
    console.log(`üìä R√©sultats - ${result.profiles?.length || 0} profils trouv√©s`);
    
    return res.json({
      success: true,
      response: result.response,
      profiles: result.profiles || [],
      analysisResults: result.analysisResults || null
    });
  } catch (error) {
    console.error('‚ùå Erreur lors du traitement de la requ√™te restaurant:', error);
    return res.status(500).json({
      success: false,
      error: "Erreur lors du traitement de la requ√™te",
      response: "D√©sol√©, une erreur s'est produite lors du traitement de votre requ√™te. Veuillez r√©essayer.",
      profiles: []
    });
  }
});

/**
 * @route POST /api/ai/leisure-insights
 * @description Obtient des insights pour un producteur de loisirs
 * @access Public
 */
router.post('/leisure-insights', async (req, res) => {
  try {
    const { producerId, producerType } = req.body;
    
    if (!producerId) {
      return res.status(400).json({
        success: false,
        message: 'ProducerId est requis'
      });
    }
    
    console.log(`üéÆ G√©n√©ration d'insights pour producteur de loisirs: ${producerId}`);
    
    // R√©cup√©rer le producteur
    const producer = await LeisureProducer.findById(producerId);
    
    if (!producer) {
      return res.status(404).json({
        success: false,
        message: 'Producteur de loisirs non trouv√©'
      });
    }
    
    // Normaliser les donn√©es du producteur
    const normalizedProducer = normalizeLeisureProducerData(producer.toObject());
    
    // Trouver des lieux similaires ou des concurrents
    const similars = await LeisureProducer.find({
      _id: { $ne: producerId },
      $or: [
        { category: { $in: normalizedProducer.category } },
        { activities: { $in: normalizedProducer.activities } }
      ]
    }).limit(5);
    
    // Normaliser les r√©sultats similaires
    const normalizedSimilars = similars.map(similar => 
      normalizeLeisureProducerData(similar.toObject())
    );
    
    // Construire les profils pour l'interface
    const profiles = [
      {
        id: normalizedProducer._id.toString(),
        type: 'leisureProducer',
        name: normalizedProducer.name || normalizedProducer.lieu || 'Sans nom',
        address: normalizedProducer.address || normalizedProducer.adresse,
        category: normalizedProducer.category || [],
        image: normalizedProducer.photo || normalizedProducer.image
      },
      ...normalizedSimilars.map(similar => ({
        id: similar._id.toString(),
        type: 'leisureProducer',
        name: similar.name || similar.lieu || 'Sans nom',
        address: similar.address || similar.adresse,
        category: similar.category || [],
        image: similar.photo || similar.image
      }))
    ];
    
    // Construire la r√©ponse textuelle
    const response = `Voici une analyse de votre √©tablissement de loisirs "${normalizedProducer.name || normalizedProducer.lieu || 'Sans nom'}". ` + 
                    `Vous proposez des activit√©s dans ${normalizedProducer.category ? normalizedProducer.category.join(', ') : 'divers domaines'}. ` +
                    `J'ai √©galement identifi√© ${normalizedSimilars.length} √©tablissements similaires qui pourraient repr√©senter votre concurrence directe.`;
    
    return res.json({
      success: true,
      response,
      profiles
    });
  } catch (error) {
    console.error('‚ùå Erreur lors de la g√©n√©ration d\'insights pour producteur de loisirs:', error);
    return res.status(500).json({
      success: false,
      error: "Erreur lors de la g√©n√©ration d'insights",
      response: "D√©sol√©, une erreur s'est produite lors de la g√©n√©ration des insights. Veuillez r√©essayer.",
      profiles: []
    });
  }
});

/**
 * @route POST /api/ai/wellness-insights
 * @description Obtient des insights pour un producteur de bien-√™tre
 * @access Public
 */
router.post('/wellness-insights', async (req, res) => {
  try {
    const { producerId, producerType } = req.body;
    
    if (!producerId) {
      return res.status(400).json({
        success: false,
        message: 'ProducerId est requis'
      });
    }
    
    console.log(`üíÜ G√©n√©ration d'insights bien-√™tre pour le producteur: ${producerId}`);
    
    // Requ√™te d'analyse automatique pour le bien-√™tre
    const query = "Analyse ma performance en tant qu'√©tablissement de bien-√™tre par rapport aux concurrents similaires et donne-moi les principales recommandations pour am√©liorer ma visibilit√© et mon taux de r√©servation";
    const result = await processProducerQuery(query, producerId, 'wellnessProducer');
    
    console.log(`üìä Insights bien-√™tre g√©n√©r√©s avec ${result.profiles?.length || 0} profils extraits`);
    
    return res.json({
      success: true,
      response: result.response,
      profiles: result.profiles || [],
      analysisResults: result.analysisResults || null
    });
  } catch (error) {
    console.error('‚ùå Erreur lors de la g√©n√©ration des insights bien-√™tre:', error);
    return res.status(500).json({
      success: false,
      error: "Erreur lors de la g√©n√©ration des insights",
      response: "D√©sol√©, une erreur s'est produite lors de la g√©n√©ration des insights. Veuillez r√©essayer.",
      profiles: []
    });
  }
});

/**
 * @route POST /api/ai/beauty-insights
 * @description Obtient des insights pour un √©tablissement de beaut√©
 * @access Public
 */
router.post('/beauty-insights', async (req, res) => {
  try {
    const { producerId, producerType } = req.body;
    
    if (!producerId) {
      return res.status(400).json({
        success: false,
        message: 'ProducerId est requis'
      });
    }
    
    console.log(`üíÖ G√©n√©ration d'insights beaut√© pour le producteur: ${producerId}`);
    
    // Requ√™te d'analyse automatique pour la beaut√©
    const query = "Analyse ma performance en tant qu'√©tablissement de beaut√© par rapport aux concurrents similaires et donne-moi les principales recommandations pour am√©liorer ma visibilit√© et mon taux de r√©servation";
    const result = await processProducerQuery(query, producerId, 'beautyPlace');
    
    console.log(`üìä R√©sultats - ${result.profiles?.length || 0} profils trouv√©s`);
    
    return res.json({
      success: true,
      response: result.response,
      profiles: result.profiles || [],
      analysisResults: result.analysisResults || null
    });
  } catch (error) {
    console.error('‚ùå Erreur lors du traitement de la requ√™te beaut√©:', error);
    return res.status(500).json({
      success: false,
      error: "Erreur lors du traitement de la requ√™te",
      response: "D√©sol√©, une erreur s'est produite lors du traitement de votre requ√™te. Veuillez r√©essayer.",
      profiles: []
    });
  }
});

/**
 * @route POST /api/ai/complex-query
 * @description Traite une requ√™te utilisateur complexe avec contexte utilisateur
 * @example
 * // Requ√™te: "Restaurant japonais puis spectacle ce soir"
 * {
 *   "userId": "user123",
 *   "query": "Restaurant japonais puis spectacle ce soir"
 * }
 */
router.post('/complex-query', async (req, res) => {
  try {
    const { query, userId, options } = req.body;
    
    if (!query) {
      return res.status(400).json({
        success: false,
        message: 'Le param√®tre query est requis'
      });
    }
    
    console.log(`üîç Traitement de requ√™te complexe: "${query}" (userId: ${userId || 'anonyme'})`);
    
    // Always call the service with the parameters in the correct order
    const result = await processUserQuery(query, userId, {
      checkSocial: true,
      ...options
    });
    
    console.log(`üìä R√©sultats complexes - ${result.resultCount || 0} r√©sultats trouv√©s`);
    console.log(`üìä Contexte social: ${result.hasSocialContext}, S√©quence: ${result.hasSequence}`);
    
    // Format de r√©ponse direct
    return res.json({
      success: true,
      query: result.query,
      intent: result.intent,
      entities: result.entities,
      resultCount: result.resultCount || 0,
      executionTimeMs: result.executionTimeMs,
      response: result.response,
      profiles: result.profiles || [],
      hasSocialContext: result.hasSocialContext,
      hasSequence: result.hasSequence
    });
  } catch (error) {
    console.error('‚ùå Erreur lors du traitement de la requ√™te complexe:', error);
    return res.status(500).json({
      success: false,
      query: req.body.query,
      error: "Erreur lors du traitement de la requ√™te",
      response: "D√©sol√©, une erreur s'est produite lors du traitement de votre requ√™te. Veuillez r√©essayer.",
      profiles: []
    });
  }
});

/**
 * @route GET /api/ai/social/friends-choices/:userId
 * @description R√©cup√®re les choices r√©cents des amis d'un utilisateur
 */
router.get('/social/friends-choices/:userId', async (req, res) => {
  try {
    const { userId } = req.params;
    
    if (!userId) {
      return res.status(400).json({
        success: false,
        message: 'L\'ID utilisateur est requis'
      });
    }
    
    // Utiliser le service AI pour r√©cup√©rer les choices des amis
    const friendsChoices = await getFriendsChoices(userId);
    
    return res.json({
      success: true,
      count: friendsChoices.length,
      data: friendsChoices
    });
  } catch (error) {
    console.error('‚ùå Erreur lors de la r√©cup√©ration des choices des amis:', error);
    return res.status(500).json({
      success: false,
      message: 'Erreur serveur lors de la r√©cup√©ration des choices des amis',
      error: error.message
    });
  }
});

/**
 * @route GET /api/ai/popular/places
 * @description R√©cup√®re les lieux avec le plus de choices
 */
router.get('/popular/places', async (req, res) => {
  try {
    const limit = req.query.limit ? parseInt(req.query.limit) : 20;
    
    // Utiliser le service AI pour r√©cup√©rer les lieux populaires
    const popularPlaces = await getPlacesWithMostChoices(limit);
    
    return res.json({
      success: true,
      count: popularPlaces.length,
      data: popularPlaces
    });
  } catch (error) {
    console.error('‚ùå Erreur lors de la r√©cup√©ration des lieux populaires:', error);
    return res.status(500).json({
      success: false,
      message: 'Erreur serveur lors de la r√©cup√©ration des lieux populaires',
      error: error.message
    });
  }
});

// DEBUGGING: Log the controller and function before defining the route
console.log('üîç aiController:', aiController);
console.log('üîç aiController.getRecommendations:', aiController.getRecommendations);

// DEBUGGING: Log middleware and handler before defining the GET route
console.log('\nüîç Before GET /:producerType/:producerId/recommendations:');
console.log('üîç authenticateToken:', requireAuth);
console.log('üîç checkProducerAccess:', checkProducerAccess);
console.log('üîç aiController.getRecommendations:', aiController.getRecommendations);

// Fetches AI-generated recommendations for the producer dashboard
// Temporarily removed middleware for debugging
router.get('/:producerType/:producerId/recommendations', requireAuth, checkProducerAccess, aiController.getRecommendations);

// DEBUGGING: Log middleware and handler before defining the POST route
console.log('\nüîç Before POST /producer-query:');
console.log('üîç authenticateToken:', requireAuth);
console.log('üîç checkProducerAccess:', checkProducerAccess);
console.log('üîç aiController.handleProducerQuery:', aiController.handleProducerQuery);

// POST /api/ai/producer-query
// Handles natural language queries from the producer via the dashboard chat
router.post('/producer-query', requireAuth, checkProducerAccess, aiController.handleProducerQuery);

// Make sure the router is properly exported
module.exports = router;